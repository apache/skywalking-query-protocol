# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Request to create a profiler task
input AsyncProfilerTaskCreationRequest {
    # need to monitor service id
    serviceId: ID!
    # serviceInstanceIds to be monitored under the given service.
    serviceInstanceIds: [String!]!
    # duration of this task (second)
    duration: Int!
    # when the segment starts to execute, how long must it take before the monitor can be enable
    events: [AsyncProfilerEventType!]!
    # other async-profiler exec options, e.g. alloc=2k,lock=2s
    execArgs: String
}

# AsyncProfiler task create result
type AsyncProfilerTaskCreationResult {
    # if null means the task create success, otherwise get create error reason
    errorReason: AsyncProfilerTaskCreationErrorType

    # get task id when create success
    id: String
}
# AsyncProfiler task creation error type
enum AsyncProfilerTaskCreationErrorType {
    # service cannot be null
    SERVICE_ID_IS_NULL
    # duration cannot be negative
    DURATION_IS_NEGATIVE
    # events cannot be empty
    EVENT_IS_EMPTY
    # current service already has monitor async profiler task execute at this time
    ALREADY_PROFILING
}

# Request to query profiler task list
input AsyncProfilerTaskListRequest {
    # serviceId to monitored under the special service.
    serviceId: ID!
    # start time
    startTime: Long
    # end time
    endTime: Long
    # The most recent limit number of tasks
    limit: Int
}

# Request to query flame graph analyzation
input AsyncProfilerAnalyzationRequest {
    # task id
    taskId: ID!
    # merge all
    instanceIds: [String]!
    # jfr event type
    eventType: JFREventType!
}

# AsyncProfiler task list result
type AsyncProfilerTaskListResult {
    # if null or empty means the task create success, otherwise get create error reason
    errorReason: String

    # get data id when create success
    tasks: [AsyncProfilerTask]
}

# AsyncProfiler task data
type AsyncProfilerTask {
    id: String!
    serviceId: String!
    serviceInstanceIds: [String!]!
    createTime: Long!
    events: [AsyncProfilerEventType!]!
    duration: Int!
    execArgs: String
}

# AsyncProfiler flame graph result
type AsyncProfilerStackTree {
    type: JFREventType!
    elements: [AsyncProfilerStackElement!]!
}

# AsyncProfiler thread stack analyze tree element
type AsyncProfilerStackElement {
    # work for tree building, id matches multiple parentId
    id: ID!
    parentId: ID!
    # stack code signature
    codeSignature: String!
    # current node and children sampling times
    total: Long!
    # current node sampling times
    self: Long!
}

# AsyncProfiler task create result
type AsyncProfilerAnalyzation {
    # if null or empty means the task create success, otherwise get create error reason
    errorReason: String
    # get frameTree with event
    tree: AsyncProfilerStackTree
}

# AsyncProfiler task progress result
type AsyncProfilerTaskProgress {
    # query all task logs
    logs: [AsyncProfilerTaskLog]!
    # instances of failed task execution
    errorInstanceIds: [ID]
    # instances of successful task execution
    successInstanceIds: [ID]
}

# AsyncProfiler task execution log
type AsyncProfilerTaskLog {
    id: String!
    # execute instance
    instanceId: ID!
    instanceName: String!
    # operation type
    operationType: AsyncProfilerTaskLogOperationType!
    # operation time
    operationTime: Long!
}

# AsyncProfiler task log operation type
enum AsyncProfilerTaskLogOperationType {
    # when sniffer has notified
    NOTIFIED,
    # when sniffer has execution finished to report
    EXECUTION_FINISHED
    # when sniffer finished task but jfr file is to large that oap server can not receive
    JFR_UPLOAD_FILE_TOO_LARGE_ERROR
    # when sniffer fails to execute its task
    EXECUTION_TASK_ERROR
}

# Profiler task event type
enum AsyncProfilerEventType {
    CPU
    WALL
    LOCK
    ALLOC
    CTIMER
    ITIMER
}

# JFR event type
enum JFREventType {
    UNKNOWN
    EXECUTION_SAMPLE
    JAVA_MONITOR_ENTER
    THREAD_PARK
    OBJECT_ALLOCATION_IN_NEW_TLAB
    OBJECT_ALLOCATION_OUTSIDE_TLAB
    PROFILER_LIVE_OBJECT
}

extend type Mutation {
    # create a new async profiler task
    createAsyncProfilerTask(asyncProfilerTaskCreationRequest: AsyncProfilerTaskCreationRequest!): AsyncProfilerTaskCreationResult!
}

extend type Query {
    # query tasks under service
    queryAsyncProfilerTaskList(request: AsyncProfilerTaskListRequest!): AsyncProfilerTaskListResult!
    # query task progress
    queryAsyncProfilerTaskProgress(taskId: String): AsyncProfilerTaskProgress!
    # query the flame graph produced by async-profiler
    queryAsyncProfilerAnalyze(request: AsyncProfilerAnalyzationRequest!): AsyncProfilerAnalyzation!
}

